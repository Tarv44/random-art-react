[{"/Users/jonahtarver/coding/www/react-random-art-richter/src/Grid/Grid.js":"1","/Users/jonahtarver/coding/www/react-random-art-richter/src/App.js":"2","/Users/jonahtarver/coding/www/react-random-art-richter/src/index.js":"3","/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/fillGrid.js":"4","/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/generateEmptyGrid.js":"5","/Users/jonahtarver/coding/www/react-random-art-richter/src/GridContext.js":"6","/Users/jonahtarver/coding/www/react-random-art-richter/src/GridForm/GridForm.js":"7","/Users/jonahtarver/coding/www/react-random-art-richter/src/Nav/Nav.js":"8","/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/colorFunctions.js":"9","/Users/jonahtarver/coding/www/react-random-art-richter/src/colorFillChances/colorFillChances.js":"10","/Users/jonahtarver/coding/www/react-random-art-richter/src/Cell/Cell.js":"11","/Users/jonahtarver/coding/www/react-random-art-richter/src/TimeSizeConstraints/TimeSizeConstraints.js":"12","/Users/jonahtarver/coding/www/react-random-art-richter/src/NodeConstraints/NodeConstraints.js":"13","/Users/jonahtarver/coding/www/react-random-art-richter/src/GridStatus/GridStatus.js":"14","/Users/jonahtarver/coding/www/react-random-art-richter/src/SkewConstraints/SkewConstraints.js":"15"},{"size":699,"mtime":1611263781144,"results":"16","hashOfConfig":"17"},{"size":5696,"mtime":1611264181302,"results":"18","hashOfConfig":"17"},{"size":263,"mtime":1608105442000,"results":"19","hashOfConfig":"17"},{"size":6524,"mtime":1611263578739,"results":"20","hashOfConfig":"17"},{"size":1250,"mtime":1609315498000,"results":"21","hashOfConfig":"17"},{"size":364,"mtime":1610179395980,"results":"22","hashOfConfig":"17"},{"size":1150,"mtime":1610179475199,"results":"23","hashOfConfig":"17"},{"size":357,"mtime":1611216443103,"results":"24","hashOfConfig":"17"},{"size":438,"mtime":1608103096000,"results":"25","hashOfConfig":"17"},{"size":2192,"mtime":1610235259287,"results":"26","hashOfConfig":"17"},{"size":866,"mtime":1610146131557,"results":"27","hashOfConfig":"17"},{"size":1659,"mtime":1611264145664,"results":"28","hashOfConfig":"17"},{"size":2736,"mtime":1611263699911,"results":"29","hashOfConfig":"17"},{"size":583,"mtime":1611264339003,"results":"30","hashOfConfig":"17"},{"size":975,"mtime":1611263698391,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"19zx1a4",{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"34"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"61"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/jonahtarver/coding/www/react-random-art-richter/src/Grid/Grid.js",[],["72","73"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/App.js",["74","75","76"],"import React, {Component} from 'react';\nimport Grid from './Grid/Grid';\nimport generateEmptyGrid from './functions/generateEmptyGrid';\nimport {randomRGB} from './functions/colorFunctions';\nimport {fillCellGroup, fillStart} from './functions/fillGrid';\nimport Nav from './Nav/Nav';\nimport {Route ,Redirect} from 'react-router-dom';\nimport GridStatus from './GridStatus/GridStatus';\nimport GridContext from './GridContext';\nimport GridForm from './GridForm/GridForm'\n\nimport './App.css';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      counter: 0,\n      large: {\n        totalColumns: 250,\n        totalRows: 120,\n        totalCells: null,\n        totalCellsFilled: 0,\n        filling: false,\n        fillCenters: [],\n        fillableCells: [],\n        grid: null,\n        formConstraints: {\n          colorChances: {\n            same: 80,\n            skew: 19\n          },\n          skew: {\n            changeRange: 10\n          },\n          node: {\n            totalStart: 1,\n            chanceNew: 0,\n            chanceNewSame: 0,\n            chanceNewDiff: 0\n          },\n          timeSize: {\n            intervalDelay: 500,\n            fillGroupSize: 50\n          }\n        }\n      },\n      extraLarge: {\n        totalColumns: 1250,\n        totalRows: 600,\n        totalCells: null,\n        totalCellsFilled: 0,\n        filling: false,\n        fillCenters: [],\n        fillableCells: [],\n        grid: null,\n        formConstraints: {\n          colorChances: {\n            same: 80,\n            skew: 19\n          },\n          skew: {\n            changeRange: 10\n          },\n          node: {\n            totalStart: 1,\n            chanceNew: 0,\n            chanceNewSame: 0,\n            chanceNewDiff: 0\n          },\n          timeSize: {\n            intervalDelay: 250,\n            fillGroupSize: 10\n          }\n        }\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.setState(prevState => ({\n      // emptyGridsRendered: true,\n      large: {\n        ...prevState.large,\n        totalCells: this.state.large.totalRows * this.state.large.totalColumns\n      },\n      extraLarge: {\n        ...prevState.extraLarge,\n        totalCells: this.state.extraLarge.totalRows * this.state.extraLarge.totalColumns\n      }\n\n    }))   \n  }\n\n  handleFormStart = (event, gridId) => {\n    event.preventDefault();\n    \n    this.setState({ [gridId]: fillStart(this.state[gridId], gridId) })\n\n    const intervalDelay = this.state[gridId].formConstraints.timeSize.intervalDelay;\n    const fillInterval = setInterval(() => {\n      if (this.state[gridId].fillableCells.length !== 0 && this.state[gridId].filling) {\n        const newState = fillCellGroup(this.state[gridId])\n        this.setState({\n          [gridId]: newState\n        })\n      } else {\n        if (this.state[gridId].filling) {\n          this.setState({\n            [gridId]: {\n              ...this.state[gridId],\n              filling: false\n            }\n          })\n        }\n        clearInterval(fillInterval);\n        console.log('interval cleared')\n      }\n    },intervalDelay);\n  }\n\n\n  handleFormStop = (event, gridId) => {\n    event.preventDefault();\n\n    this.setState({\n      [gridId]: {\n        ...this.state[gridId],\n        filling: false\n      }\n    })\n  }\n\n  updateColorChances = (gridId, valueId, value) => {\n    this.setState(prevState => ({\n      ...prevState,\n      [gridId]: {\n        ...prevState[gridId],\n        formConstraints: {\n          ...prevState[gridId].formConstraints,\n          colorChances: {\n            ...prevState[gridId].formConstraints.colorChances,\n            [valueId]: value\n          }\n        }\n      }\n    }))\n  }\n\n  updateSkewConstraints = (gridId, valueId, value) => {\n    this.setState(prevState => ({\n      ...prevState,\n      [gridId]: {\n        ...prevState[gridId],\n        formConstraints: {\n          ...prevState[gridId].formConstraints,\n          skew: {\n            ...prevState[gridId].formConstraints.skew,\n            [valueId]: value\n          }\n        }\n      }\n    }))\n  }\n\n  updateNodeConstraints = (gridId, valueId, value) => {\n    this.setState(prevState => ({\n      ...prevState,\n      [gridId]: {\n        ...prevState[gridId],\n        formConstraints: {\n          ...prevState[gridId].formConstraints,\n          node: {\n            ...prevState[gridId].formConstraints.node,\n            [valueId]: value\n          }\n        }\n      }\n    }))\n  }\n\n  updateTimeSizeConstraints = (gridId, valueId, value) => {\n    this.setState(prevState => ({\n      ...prevState,\n      [gridId]: {\n        ...prevState[gridId],\n        formConstraints: {\n          ...prevState[gridId].formConstraints,\n          timeSize: {\n            ...prevState[gridId].formConstraints.timeSize,\n            [valueId]: value\n          }\n        }\n      }\n    }))\n  }\n  \n  \n  render() {\n    const contextValue = {\n      large: this.state.large,\n      extraLarge: this.state.extraLarge,\n      formStart: this.handleFormStart,\n      updateColorChances: this.updateColorChances,\n      updateSkewConstraints: this.updateSkewConstraints,\n      updateNodeConstraints: this.updateNodeConstraints,\n      updateTimeSizeConstraints: this.updateTimeSizeConstraints,\n      formStop: this.handleFormStop\n    }\n\n    return (\n      <GridContext.Provider value={contextValue}>\n        <div className=\"App\">\n          <Nav />\n          <main >\n            {<Route exact path={'/grid/:gridId'} component={GridForm}/>}\n            {<Route exact path={'/grid/:gridId'} component={GridStatus}/>}\n            {<Route exact path={'/grid/:gridId'} component={Grid}/>}\n          </main>\n        </div> \n      </GridContext.Provider>    \n    );\n  }\n  \n}\n\nexport default App;","/Users/jonahtarver/coding/www/react-random-art-richter/src/index.js",[],"/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/fillGrid.js",["77","78","79"],"import React, {Component} from 'react';\nimport {randomRGB} from './colorFunctions';\nimport generateEmptyGrid from './generateEmptyGrid';\n\nfunction randomFromRange(range) {\n    return Math.floor(Math.random() * range)\n}\n\nfunction randomFromArray(array) {\n    const i = randomFromRange(array.length)\n    return array[i]\n}\n\nfunction selectRandomCell(totalColumns, totalRows) {\n    const column = randomFromRange(totalColumns);\n    const row = randomFromRange(totalRows);\n    return {column, row}\n}\n\nfunction selectFillCenter(currentGrid) {\n    const index = randomFromRange(currentGrid.fillCenters.length)\n    const coors = currentGrid.fillCenters[index]\n    return {coors, index}\n    \n}\n\nfunction allSurrCoors(gridCols, cellCoor) {\n    const columns = [cellCoor.column-1, cellCoor.column, cellCoor.column+1]\n        .filter(num => num > -1 && num < gridCols.length)\n    const rows = [cellCoor.row-1, cellCoor.row, cellCoor.row+1]\n        .filter(num => num > -1 && num < gridCols[0].length)\n    const coors = [];\n    for (let c = 0; c < columns.length; c++) {\n        for (let r = 0; r < rows.length; r++) {\n            const id = `c${columns[c]}r${rows[r]}`\n            const coor = {column: columns[c], row: rows[r], id}\n            if (!(cellCoor.column === coor.column && cellCoor.row === coor.row)) {\n                coors.push(coor)\n            }\n\n        }\n    }\n    return coors\n}\n\nfunction getSurrEmpties(gridCols, cellCoor) {\n    const surrCoors = allSurrCoors(gridCols, cellCoor)\n    const surrEmpties = surrCoors.filter(coor => \n        gridCols[coor.column][coor.row].color === null)\n    return surrEmpties\n}\n\nfunction getSurrColors(gridCols, cellCoor) {\n    const coors = allSurrCoors(gridCols, cellCoor);\n    const surrColors = coors.filter(coor =>\n        gridCols[coor.column][coor.row].color !== null)\n    return surrColors\n}\n\nfunction updateFillableCells(gridCols, fillableCells, currentCoor) {\n    const newList = fillableCells.filter(cell => cell.id !== currentCoor.id)\n    const allSurrEmpties = getSurrEmpties(gridCols, currentCoor)\n    const newFillables = []\n    for(let i = 0; i < allSurrEmpties.length; i++) {\n        if(!fillableCells.some(cell => cell.id === allSurrEmpties[i].id)) {\n            newFillables.push(allSurrEmpties[i])\n        }\n    }\n    return newList.concat(newFillables)\n}\n\nfunction skewColor(color, currentGridConstraints) {\n    const range = currentGridConstraints.skew.changeRange\n    let red \n    let green\n    let blue\n    const redChange = (Math.floor(Math.random() * range) + 1)\n    const greenChange = (Math.floor(Math.random() * range) + 1)\n    const blueChange = (Math.floor(Math.random() * range) + 1)\n\n    if (Math.random() < .5) {\n        red = color.red + redChange\n        if (red > 255) {\n            red = 255\n        }\n    } else {\n        red = color.red - redChange\n        if (red < 0) {\n            red = 0\n        }\n    }\n\n    if (Math.random() < .5) {\n        green = color.green + greenChange\n        if (green > 255) {\n            green = 255\n        }\n    } else {\n        green = color.green - greenChange\n        if (green < 0) {\n            green = 0\n        }\n    }\n\n    if (Math.random() < .5) {\n        blue = color.blue + blueChange\n        if (blue > 255) {\n            blue = 255\n        }\n    } else {\n        blue = color.blue - blueChange\n        if (blue < 0) {\n            blue = 0\n        }\n    }\n\n    const rgb = `rgba(${red}, ${green}, ${blue}, 1)`\n\n    const newColor = {red, green, blue, rgb}\n    return newColor\n}\n\nfunction selectNewColor(surrColor, currentGridConstraints) {\n    const probability = (Math.random()*100)\n    const colorChances = currentGridConstraints.colorChances\n    let newColor\n    if (probability <= parseFloat(colorChances.same)) {\n        newColor = surrColor\n    } else if (probability <= parseFloat(colorChances.same) + parseFloat(colorChances.skew)) {\n        newColor = skewColor(surrColor, currentGridConstraints)\n    } else {\n        newColor = randomRGB()\n    }\n    return newColor\n}\n\nfunction fillInitCells(currentGrid) {\n    const totalStartNodes = currentGrid.formConstraints.node.totalStart\n    for (let i = 1; i <= totalStartNodes; i++) {\n        const cellCoor = selectRandomCell(currentGrid.totalColumns, currentGrid.totalRows);\n        currentGrid.grid.columns[cellCoor.column][cellCoor.row].color = randomRGB();\n        currentGrid.grid.columns[cellCoor.column][cellCoor.row].opacity = 1;\n        currentGrid.totalCellsFilled += 1\n        currentGrid.fillCenters.push(cellCoor)\n        currentGrid.fillableCells = currentGrid.fillableCells.concat(getSurrEmpties(currentGrid.grid.columns, cellCoor))\n    }\n    return currentGrid\n}\n\nexport function fillStart(currentGrid, gridId) {\n    if (currentGrid.totalCellsFilled === currentGrid.totalCells || currentGrid.grid === null) {\n        currentGrid.grid = generateEmptyGrid(currentGrid, gridId)\n        currentGrid.totalCellsFilled = 0\n    }\n\n    if (currentGrid.totalCellsFilled === 0) {\n        currentGrid = fillInitCells(currentGrid)\n    }\n\n    currentGrid.filling = true\n    return currentGrid\n}\n\nfunction fillColor(currentGrid) {\n    const gridCols = currentGrid.grid.columns\n    const fillableCoor = randomFromArray(currentGrid.fillableCells)\n    \n\n    const fillableCells = updateFillableCells(gridCols, currentGrid.fillableCells, fillableCoor)\n\n    const surrColorsCoors = getSurrColors(gridCols, fillableCoor)\n    const baseColorCoor = randomFromArray(surrColorsCoors)\n    const baseColor = currentGrid.grid.columns[baseColorCoor.column][baseColorCoor.row].color\n    const newColor = selectNewColor(baseColor, currentGrid.formConstraints)\n    currentGrid.grid.columns[fillableCoor.column][fillableCoor.row].color = newColor;\n    currentGrid.grid.columns[fillableCoor.column][fillableCoor.row].opacity = 1;\n    currentGrid.totalCellsFilled += 1;\n    // currentGrid.fillCenters = fillCenters\n    currentGrid.fillableCells = fillableCells\n\n    return currentGrid\n}\n\nexport function fillCellGroup(currentGrid) {\n    const groupSizePerc = currentGrid.formConstraints.timeSize.fillGroupSize / 100\n    const groupSize = Math.floor(currentGrid.totalCells * groupSizePerc)\n    const cellsLeft = currentGrid.totalCells - currentGrid.totalCellsFilled\n    let newGrid = currentGrid\n    if (cellsLeft > groupSize) {\n        for (let i = 0; i < groupSize; i++) {\n            newGrid = fillColor(newGrid)\n        }\n    } else {\n        for (let i = 0; i < cellsLeft; i++) {\n            newGrid = fillColor(newGrid)\n        }\n    }\n    return newGrid\n}","/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/generateEmptyGrid.js",["80","81"],"import {randomRGB} from './colorFunctions';\n\nfunction generateEmptyCell(col, r, gridSize, animationDelay) {\n    const cellId = `c${col}r${r}`\n    const emptyCell = {\n        id: cellId,\n        column: col,\n        row: r,\n        gridSize: gridSize,\n        opacity: 0,\n        color: null\n    }\n    return emptyCell\n}\n\nexport default function generateEmptyGrid(state, gridSize) {\n    const gridState = {}\n    const gridArray = []\n    let animationDelay = 0\n    for (let i = 0; i < state.totalColumns; i++) {\n        const columnArray = []\n        for (let p = 0; p < state.totalRows; p++) {\n            columnArray.push(generateEmptyCell(i, p, gridSize, animationDelay))\n            animationDelay += .01\n        }\n        gridArray.push(columnArray)\n    }\n    gridState.columns = gridArray\n    return gridState\n}\n\nexport function generateDummyGrid() {\n    const gridState = {}\n    const gridArray = []\n    let animationDelay = 0\n    for (let i = 0; i < 10; i++) {\n        const columnArray = []\n        for (let p = 0; p < 10; p++) {\n            columnArray.push(generateEmptyCell(i, p, 'testSize', .05))\n            animationDelay += .01\n        }\n        gridArray.push(columnArray)\n    }\n    gridState.columns = gridArray\n    return gridState\n}",["82","83"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/GridContext.js",[],["84","85"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/GridForm/GridForm.js",[],["86","87"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/Nav/Nav.js",[],["88","89"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/functions/colorFunctions.js",["90"],"import React from 'react';\n\nfunction randomFromRange(range) {\n    return Math.floor(Math.random() * range)\n}\n\nexport function randomRGB() {\n    const colorObject = {}\n    colorObject.red = randomFromRange(256)\n    colorObject.green = randomFromRange(256)\n    colorObject.blue = randomFromRange(256)\n    const rgb = `rgba(${colorObject.red}, ${colorObject.green}, ${colorObject.blue}, 1)`\n    colorObject.rgb = rgb\n    return colorObject\n}","/Users/jonahtarver/coding/www/react-random-art-richter/src/colorFillChances/colorFillChances.js",[],["91","92"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/Cell/Cell.js",["93"],"/Users/jonahtarver/coding/www/react-random-art-richter/src/TimeSizeConstraints/TimeSizeConstraints.js",[],"/Users/jonahtarver/coding/www/react-random-art-richter/src/NodeConstraints/NodeConstraints.js",[],"/Users/jonahtarver/coding/www/react-random-art-richter/src/GridStatus/GridStatus.js",[],"/Users/jonahtarver/coding/www/react-random-art-richter/src/SkewConstraints/SkewConstraints.js",[],{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","severity":1,"message":"99","line":3,"column":8,"nodeType":"100","messageId":"101","endLine":3,"endColumn":25},{"ruleId":"98","severity":1,"message":"102","line":4,"column":9,"nodeType":"100","messageId":"101","endLine":4,"endColumn":18},{"ruleId":"98","severity":1,"message":"103","line":7,"column":16,"nodeType":"100","messageId":"101","endLine":7,"endColumn":24},{"ruleId":"98","severity":1,"message":"104","line":1,"column":8,"nodeType":"100","messageId":"101","endLine":1,"endColumn":13},{"ruleId":"98","severity":1,"message":"105","line":1,"column":16,"nodeType":"100","messageId":"101","endLine":1,"endColumn":25},{"ruleId":"98","severity":1,"message":"106","line":20,"column":10,"nodeType":"100","messageId":"101","endLine":20,"endColumn":26},{"ruleId":"98","severity":1,"message":"102","line":1,"column":9,"nodeType":"100","messageId":"101","endLine":1,"endColumn":18},{"ruleId":"98","severity":1,"message":"107","line":40,"column":13,"nodeType":"100","messageId":"101","endLine":40,"endColumn":27},{"ruleId":"94","replacedBy":"108"},{"ruleId":"96","replacedBy":"109"},{"ruleId":"94","replacedBy":"110"},{"ruleId":"96","replacedBy":"111"},{"ruleId":"94","replacedBy":"112"},{"ruleId":"96","replacedBy":"113"},{"ruleId":"94","replacedBy":"114"},{"ruleId":"96","replacedBy":"115"},{"ruleId":"98","severity":1,"message":"104","line":1,"column":8,"nodeType":"100","messageId":"101","endLine":1,"endColumn":13},{"ruleId":"94","replacedBy":"116"},{"ruleId":"96","replacedBy":"117"},{"ruleId":"98","severity":1,"message":"107","line":23,"column":15,"nodeType":"100","messageId":"101","endLine":23,"endColumn":29},"no-native-reassign",["118"],"no-negated-in-lhs",["119"],"no-unused-vars","'generateEmptyGrid' is defined but never used.","Identifier","unusedVar","'randomRGB' is defined but never used.","'Redirect' is defined but never used.","'React' is defined but never used.","'Component' is defined but never used.","'selectFillCenter' is defined but never used.","'animationDelay' is assigned a value but never used.",["118"],["119"],["118"],["119"],["118"],["119"],["118"],["119"],["118"],["119"],"no-global-assign","no-unsafe-negation"]